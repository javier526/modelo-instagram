{
  "_args": [
    [
      {
        "raw": "yo-yo@^1.4.0",
        "scope": null,
        "escapedName": "yo-yo",
        "name": "yo-yo",
        "rawSpec": "^1.4.0",
        "spec": ">=1.4.0 <2.0.0",
        "type": "range"
      },
      "C:\\Users\\maste\\Desktop\\proyecto"
    ]
  ],
  "_from": "yo-yo@>=1.4.0 <2.0.0",
  "_id": "yo-yo@1.4.1",
  "_inCache": true,
  "_location": "/yo-yo",
  "_nodeVersion": "6.4.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/yo-yo-1.4.1.tgz_1495533886080_0.7781010665930808"
  },
  "_npmUser": {
    "name": "yoshuawuyts",
    "email": "i@yoshuawuyts.com"
  },
  "_npmVersion": "4.1.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "yo-yo@^1.4.0",
    "scope": null,
    "escapedName": "yo-yo",
    "name": "yo-yo",
    "rawSpec": "^1.4.0",
    "spec": ">=1.4.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/yo-yo/-/yo-yo-1.4.1.tgz",
  "_shasum": "9ce4b00fd880e5533b5e7f46a93d68d914ad6f64",
  "_shrinkwrap": null,
  "_spec": "yo-yo@^1.4.0",
  "_where": "C:\\Users\\maste\\Desktop\\proyecto",
  "author": {
    "name": "Max Ogden"
  },
  "bugs": {
    "url": "https://github.com/maxogden/yo-yo/issues"
  },
  "dependencies": {
    "bel": "^4.0.0",
    "morphdom": "^2.1.0"
  },
  "description": "A tiny library for building modular UI components using DOM diffing and ES6 tagged template literals",
  "devDependencies": {
    "browserify": "^13.0.1",
    "tape": "^4.5.1",
    "wzrd": "^1.3.1"
  },
  "directories": {},
  "dist": {
    "shasum": "9ce4b00fd880e5533b5e7f46a93d68d914ad6f64",
    "tarball": "https://registry.npmjs.org/yo-yo/-/yo-yo-1.4.1.tgz"
  },
  "gitHead": "92e7b0897fb217ce3e456eb3137c4ff2d1c0c801",
  "homepage": "https://github.com/maxogden/yo-yo#readme",
  "keywords": [],
  "license": "ISC",
  "main": "index.js",
  "maintainers": [
    {
      "name": "freeman-lab",
      "email": "the.freeman.lab@gmail.com"
    },
    {
      "name": "maxogden",
      "email": "max@maxogden.com"
    },
    {
      "name": "shama",
      "email": "kyle@dontkry.com"
    },
    {
      "name": "yoshuawuyts",
      "email": "i@yoshuawuyts.com"
    }
  ],
  "name": "yo-yo",
  "optionalDependencies": {},
  "readme": "# yo-yo.js\n\nA tiny library for building modular UI components using [DOM diffing](#morphdom) and [ES6 tagged template literals](#tagged-template-literals), powered by [bel](https://www.npmjs.com/package/bel) and [morphdom](https://www.npmjs.com/package/morphdom) and based on the \"yo-yo\" data binding pattern: data down, actions up. \n\nyo-yo powers the [choo framework](https://github.com/yoshuawuyts/choo), you should check it out if you want something higher level! or if you want lower level, see the module that powers yo-yo: [bel](https://www.npmjs.com/package/bel)\n\n![logo](yoyojs.png)\n\nGetting started is as easy as <pre>var element = yo\\`&lt;h1&gt;hello world!&lt;/h1&gt;\\`</pre>\n\n[Give yo-yo a spin in your browser on RequireBin](http://requirebin.com/?gist=8371be058c7c0c087ebe).\n\n## Features\n\n- React-style modular UI components that can efficiently update themselves\n- Build your own framework: [small modules that you can swap out](#modules-that-work-well-with-yo-yo) to pick your own tradeoffs\n- Uses features available in browsers today instead of inventing new syntax/APIs\n- Designed for [template literals](#tagged-template-literals), a templating feature built in to JS\n- Uses a [default DOM diffing](#morphdom) strategy based on the real DOM, not a virtual DOM\n- Compatible with vanilla DOM elements and vanilla JS data structures\n- Doesn't require hundreds of megabytes of devDependencies to build\n- 4kb minified + gzipped (6 times smaller than React), small enough for UI components to include as a dependency\n\n## About\n\n`yo-yo` is a modular UI framework, meaning there isn't much code in this repository, much of the functionality comes from other modules (see [`index.js`](index.js)). The goals of `yo-yo` are to choose a good set of default dependencies, document how to use them all together in one place, and use small enough dependencies that you can include a copy of `yo-yo` in standalone UI component modules and publish them to npm.\n\nYou can start by simply doing `require('yo-yo')` but as your app grows will most likely want to choose different tradeoffs ([add or remove dependencies](#modules-that-work-well-with-yo-yo)), and `yo-yo` is designed to let you do that without rewriting all of your code due to API changes, forcing you to use certain dependencies, or making you adopt new coding conventions.\n\nIn this way `yo-yo` is similar to the modular frameworks [mississippi](https://www.npmjs.com/package/mississippi), [http-framework](https://www.npmjs.com/package/http-framework) and [mercury](https://www.npmjs.com/package/mercury).\n\n## Installing\n\nYou can get it [from npm](http://npmjs.org/yo-yo): `npm install yo-yo`\n\nTo create a standalone copy run `browserify --standalone yo index.js > yo-yo.js`\n\n## API\n\nThe `yo-yo` API is very simple and only has two functions.\n\n### var yo = require('yo-yo')\n\nReturns the `yo` function. There is also a method on `yo` called `yo.update`.\n\n### yo\\`template\\`\n\n`yo` is a function designed to be used with [tagged template literals](#tagged-template-literals). If your template produces a string containing an HTML element, the `yo` function will take it and produce a new DOM element that you can insert into the DOM.\n\n### yo.update(targetElement, newElement, [opts])\n\nEfficiently updates the attributes and content of an element by [diffing and morphing](#morphdom) a new element onto an existing target element. The two elements + their children should have the same 'shape', as the diff between `newElement` will replace nodes in `targetElement`. `targetElement` will get efficiently updated with only the new DOM nodes from `newElement`, and `newElement` can be discarded afterwards.\n\nNote that many properties of a DOM element **are ignored** when elements are updated. [morphdom](#morphdom) only copies the following properties:\n\n- `node.firstChild`\n- `node.tagName`\n- `node.nextSibling`\n- `node.attributes`\n- `node.nodeType`\n- `node.nodeValue`\n\nIn addition to these `yo-yo` will copy event attributes (e.g. `onclick`, `onmousedown`) that you set using DOM attributes in your template.\n\n`opts` is optional and has these options:\n\n- `events` - set `false` to disable copying of event attributes. otherwise set to an array of strings, one for each event name you want to whitelist for copying. defaults to our default events\n\nThe `opts` object will also get passed to `morphdom`.\n\n## Examples\n\nHere are some UI modules implemented using `yo-yo`:\n\n- https://github.com/shama/csv-viewer\n- https://github.com/shama/fs-explorer\n\nAnd here are some simpler examples:\n\n### Creating a simple list\n\n```js\nvar yo = require('yo-yo')\n\nvar el = list([\n  'grizzly',\n  'polar',\n  'brown'\n])\n\nfunction list (items) {\n  return yo`<ul>\n    ${items.map(function (item) {\n      return yo`<li>${item}</li>`\n    })}\n  </ul>`\n}\n\ndocument.body.appendChild(el)\n````\n\n### Dynamic updates\n\n```js\nvar yo = require('yo-yo')\n\nvar numbers = [] // start empty\nvar el = list(numbers, update)\n\nfunction list (items, onclick) {\n  return yo`<div>\n    Random Numbers\n    <ul>\n      ${items.map(function (item) {\n        return yo`<li>${item}</li>`\n      })}\n    </ul>\n    <button onclick=${onclick}>Add Random Number</button>\n  </div>`\n}\n\nfunction update () {\n  // add a new random number to our list\n  numbers.push(Math.random())\n  \n  // construct a new list and efficiently diff+morph it into the one in the DOM\n  var newList = list(numbers, update)\n  yo.update(el, newList)\n}\n\ndocument.body.appendChild(el)\n```\n\nClicking the button three times results in this HTML:\n\n```\n<div>Random Numbers\n  <ul>\n    <li>0.027827488956972957</li>\n    <li>0.742044786689803</li>\n    <li>0.4440679911058396</li>\n  </ul>\n  <button>Add Random Number</button>\n</div>\n```\n\nWhen the button is clicked, thanks to `yo.update`, only a single new `<li>` is inserted into the DOM.\n  \n### Updating events\n\nEvent handlers starting with `on` that you set via attributes will get updated.\n\n```js\nfunction a () { console.log('a') }\nfunction b () { console.log('b') }\n\nvar el = yo`<button onclick=${a}>hi</button>`\nel.click() // logs 'a' to console\n\nvar newEl = yo`<button onclick=${b}>hi</button>`\nyo.update(el, newEl)\nel.click() // logs 'b' to console\n```\n\nThis works because [we explicitly copy common event attributes](update-events.js). When `yo.update` is called above, `el` is still the same JavaScript Object instance before and after. The only difference is that `yo.update` will copy any new attributes from `newEl` onto `el`. However, if you add custom properties or events to `newEl` before calling `yo.update`, for example `newEl.addEventListener('foo', handleFoo)`, they will not be copied onto `el`.\n\n## Modules that work well with yo-yo\n\nThe functionality built in to `yo-yo` covers the same problems as React and JSX, (DOM diffing and templating), using these dependencies of `yo-yo`:\n\n- [bel](https://npmjs.org/bel) - creates DOM elements from template strings\n- [morphdom](https://npmjs.org/morphdom) - efficiently morphs DOM elements (without a virtual DOM)\n\nHowever you might consider these alternatives to the above built-in choices based on your use case:\n\n- [hyperscript](https://npmjs.com/hyperscript) - alternative to template literals\n- [diffhtml](https://npmjs.com/diffhtml) - alternative to morphdom\n\nThere are also UI problems that `yo-yo` does not currently address, such as events. But it's easy to use other modules alongside `yo-yo` to create your own framework. We might even add some of these to `yo-yo` in the future:\n\n### Older Browser Compatibility / Production Performance\n\nIf you are targeting browsers that may not support template literals and would\nlike to get a performance boost by transforming your `yo-yo` elements into raw\ndocument calls:\n\n - [yo-yoify](https://github.com/shama/yo-yoify)\n\n### CSS\n\n- [dom-css](https://npmjs.org/dom-css) - inline CSS helper\n- [csjs](https://npmjs.org/csjs) - namespaced CSS helper\n- [csjs-extractify](https://github.com/rtsao/csjs-extractify) - csjs browserify transform to compile css bundles\n- [csjs-injectify](https://github.com/rtsao/csjs-injectify) - csjs browserify transform that uses [insert-css](https://npmjs.org/insert-css)\n- [sheetify](https://github.com/stackcss/sheetify) - browserify modular css transform\n- plain css files - you don't always have to use a fancy CSS module :)\n\n### State management\n\nIn `yo-yo` state management is left completely up to you. The simplest approach is the \"yo-yo\" pattern: simply call a callback up until it reaches a parent where you want to handle updates, then `yo.update()` the changes down from there, which keeps the elements isolated. But since you are just working with DOM elements, you can do `yo.update(document.querySelector('.some-other-element'), newelement)` as well.\n\nThere are also some other approaches that introduce their own patterns for managing state:\n\n- [store-emitter](https://github.com/sethvincent/store-emitter) - redux-inspired state management library\n- [minidux](https://github.com/freeman-lab/minidux) - mini version of redux\n- [good-old-fashioned-redux-example](https://github.com/freeman-lab/good-old-fashioned-redux-example) - a redux example implemented in un-fancy JS\n\n## Overview of default dependencies\n\n### bel\n\n[`bel`](https://npmjs.org/bel) is a module that takes the output from a [tagged template string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) and creates or updates (using DOM diffing) a DOM element tree.\n\n### Tagged template literals\n\n[Tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) are a way to use template literals (AKA template strings) with functions that take the output of the template string and format them in a certain way.\n\nRegular template literals lets you take code like this:\n\n```js\nvar multiline = 'hello\\n' +\n'this\\n' +\n'is\\n' +\n'multiline'\n```\n\nAnd write the same thing like this instead:\n\n```js\nvar multiline = `hello\nthis\nis\nmultiline`\n```\n\n**Tagged** template literals is where you put a function name in front of the template tags, similar to calling a function with `()` but using the backticks ```` instead of parens.\n\n```js\nfunction doesNothing () {}\n\ndoesNothing`im a string`\n```\n\nThe above example causes the `doesNothing` function to get invoked (AKA called), similar to if you did `doesNothing('im a string')`.\n\nThe difference is that tagged template strings return a specific output value.\n\n```js\nfunction logArguments (a, b, c, d) {\n  console.log(a, b, c, d)\n}\n\nlogArguments`im a string`\n```\n\nRunning the above produces `[\"im a string\", raw: \"im a string\"] undefined undefined undefined`.\n\nIf you were to just run `console.log(`im a string`)` it would produce `\"im a string\"`.\n\nHowever, tagged template strings return the above tagged template array output format.\n\nThe first item in the array is an array of all of the strings in your template string. In our case there is only one:\n\n```js\n[\"im a string\", raw: \"im a string\"]\n```\n\nThe `raw` is a property that also contains an array, but where the values are the 'raw' values as there were entered.\n\nIf you had this template for example:\n\n```js\nlogArguments`\\u9999`\n```\n\nIt would produce this as the first argument to logArguments: `[\"香\", raw: [\"\\u9999\"]]`\n\nIn template literals, tagged or not, you can interpolate values by embedding javascript expressions inside of `${}`\n\n```js\nvar name = 'bob'\nconsole.log(`hello ${name}!`)\n```\n\nThe above produces \"hello bob!\". However, when called like this:\n\n```js\nfunction logArguments (a, b, c, d) {\n  console.log(a, b, c, d)\n}\n\nvar name = 'bob'\nlogArguments`hello ${name}!`\n```\n\nIt produces the tagged template array `[\"hello \", \"!\", raw: [\"hello \", \"!\"]] \"bob\" undefined undefined`\n\nAs you can see the first argument is an array of all of the strings, and the rest of the arguments are all of the interpolated values one at a time.\n\nUsing this array you can implement your own custom way to render the strings and values. For example to simply print a string you print the strings and values in 'zipped' order):\n\n```js\nfunction printString(strings, valueA, valueB, valueC) {\n  console.log(strings[0] + valueA + strings[1] + valueB + strings[2] + valueC)\n}\n```\n\nYou could also imagine writing the above function in a more general way using loops etc. Or do something entirely different:\n\n### hyperx\n\n`yo-yo` uses a module called `bel` which in turn uses `hyperx` to turn tagged template arrays into DOM builder data.\n\nFor example:\n\n```js\nvar hyperx = require('hyperx')\n\nvar convertTaggedTemplateOutputToDomBuilder = hyperx(function (tagName, attrs, children) {\n  console.log(tagName, attrs, children)\n})\n\nconvertTaggedTemplateOutputToDomBuilder`<h1>hello world</h1>`\n```\n\nRunning this produces `h1 {} [ 'hello world' ]`, which aren't yet DOM elements but have all the data you need to build your own DOM elements however you like. These three arguments, `tagName, attrs, children` are a sort of pseudo-standard used by various DOM building libraries such as [virtual-dom](https://www.npmjs.com/package/virtual-dom), [hyperscript](https://www.npmjs.com/package/hyperscript) and [react](https://facebook.github.io/react/docs/glossary.html#react-elements), and now `hyperx` and `bel`.\n\nYou can also use DOM elements not created using `hyperx` and `bel`:\n\n```js\nvar yo = require('yo-yo')\nvar vanillaElement = document.createElement('h3')\nvanillaElement.textContent = 'Hello'\n\nvar app = yo`<div class=\"app\">${vanillaElement} World</div>`\n```\n\nRunning the above sets `app` to an element with this HTML:\n\n```\n<div class=\"app\"><h3>Hello</h3> World</div>\n```\n\n### morphdom\n\n`yo-yo` lets you do two basic things: create an element and update it. When you create an element it simply creates a new DOM element tree using hyperx and its own custom code that uses `document.createElement`.\n\nHowever, when you update an element using `yo.update()` it actually uses a module called [`morphdom`](https://npmjs.org/morphdom) to transform the existing DOM tree to match the new DOM tree while minimizing the number of changes to the existing DOM tree. This is a really similar approach to what `react` and `virtual-dom` do, except `morphdom` does not use a virtual DOM, it simply uses the actual DOM.\n\n## Benchmarks\n\nYou can find benchmarks at https://github.com/shama/yo-yo-perf\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/maxogden/yo-yo.git"
  },
  "scripts": {
    "test": "wzrd test.js"
  },
  "version": "1.4.1"
}
